
E - энергия, k - кол-во инф-ых симоволов, N - кол-во прогонов модели (сколько кодовых слов пробуем передать),
g(x) - проверочный многочлен 
codes - массив кодовых слов, полученный из функции codeBook
codeBook(k, gX):
  r - макс степень многочлена g(x), n - длина кодового слова, R - смещение, K - кол-во кодовых слов.
  переводим в цикле числа из 10-ой СС в 2-ую СС, далее используем реверс, чтобы старшие биты были слева, после складываем этот результат
  с остатком от деления его же на g(x). 
  
modGx(m_rX, gX):
  [~, r] = deconv(m_rX, gX); - данная функция возвращает целую часть и остаток от делеения 1-го параметра на 2-ой.
  Поскольку нам важен только остаток, вместо первой переменной напишем ~.
  
далее создаём массивы соотношений сигнал/шум, ошибок на бит и ошибок декодера для разных соотношений сигнал/шум
затем используется parfor для создания многопоточности, чтобы ускорить процесс моделирования программы
внутри него вызывается метод model, который возвращает 2 значения: ошибку декодера и ошибку на бит для данного соотношения сигнал/шум.

model(k, gX, codes, sigma, N):
  цикл идёт по кол-ву отправляемых кодовых слов. случайно выбирается кодовое слово из массива codes, далее меняем 1 на -1,
  а 0 на 1. После прибавляем к полученному массиву шум. Далее на приёмной стороне проверяем каждый элемент: если он меньше       нуля, то   в новый массив на эту позицию пишем 1, иначе 0. Затем сверяем полученный результат с изначально отправленным 
  словом, накидывая счётчик ошибок в переменную flag_sum. Если она будет больше нуля, но остаток от деления полученного многочлена на gX     будет нулевым, то это говорит нам о том, что декодер вынес ошибочное решение. Ошибки на бит - прибавляем кол-во ошибочных бит. В конце     усредняем значения по кол-ву раз моделирования и для ошибки на бит ещё и по длине кодового слова.
  
Дальше подсчитываем теоритические значения.
